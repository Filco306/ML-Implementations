data = data[data[,3] <= pointToPred[3],]
temps_data = as.matrix(data[,5])
distances = apply(data[,1:2], 1, function(dataCoords) {
return(distHaversine(dataCoords, pointToPred[1:2]))
})
kernSum = as.matrix(timeKernel(time1 = rep(pointToPred[4], times = nrow(data)),
time2 = data[,4], h = h_time) +
gaussianDistKernel(dist = distances,
h = h_distance) +
gaussianDateKernel(rep(pointToPred[3],
times = nrow(data)),
x2 = data[,3],
h = h_date))
above = (t(kernSum)%*%temps_data)[1,1]
below = sum(kernSum)
return(above/below)
}
pred_point_prod_kernel = function(pointToPred, data) {
data = data[data[,3] <= pointToPred[3],]
temps_data = as.matrix(data[,5])
distances = apply(data[,1:2], 1, function(dataCoords) {
return(distHaversine(dataCoords, pointToPred[1:2]))
})
kernProd = as.matrix(timeKernel(time1 = rep(pointToPred[4], times = nrow(data)),
time2 = data[,4],
h = h_time) *
gaussianDistKernel(dist = distances,
h = h_distance) *
gaussianDateKernel(day1 = rep(pointToPred[3], times = nrow(data)),
day2 = data[,3],
h = h_date))
above = (t(kernProd)%*%temps_data)[1,1]
below = sum(kernProd)
return(above/below)
}
norrkopingTimes = get_points(stationName = "Norrköping",
date = date,
times = times,
monthDay = monthDay)
LinkopingTimes = get_points(stationName = "Linköping",
date = date,
times = times,
monthDay = monthDay)
View(LinkopingTimes)
# Calculate temp
tempsSum = as.numeric()
tempsProd = as.numeric()
for (i in 1:nrow(norrkopingTimes)) {
tempsSum[i] = pred_point_sum_kernel(norrkopingTimes[i,], data = featuresToUse)
tempsProd[i] = pred_point_prod_kernel(norrkopingTimes[i,], data = featuresToUse)
}
h_distance <- 100000 # reasonable that it is the same within 200km more or less
h_date <- 45 # If the year was extra cold. Reasonable to have within one year.
h_time <- 1 # About an hour ish. Reasonable.
h_distance <- 100000 # reasonable that it is the same within 200km more or less
h_date <- 45 # If the year was extra cold. Reasonable to have within one year.
h_time <- 1 # About an hour ish. Reasonable.
set.seed(1234567890)
library(geosphere)
stations <- read.csv("stations.csv",
stringsAsFactors=FALSE,
fileEncoding="latin1")
temps <- read.csv("temps50k.csv")
# Creating Month and Day of year.
temps$MonthDay = factor(substr(as.character(temps$date),
start = 6,
stop = 10))
st <- merge(stations,temps,by="station_number")
date <- "2013-11-04" # The date to predict (up to the students)
times <- c("04:00:00", "06:00:00", "08:00:00", "10:00:00",
"12:00:00", "14:00:00", "16:00:00", "18:00:00",
"20:00:00", "22:00:00", "00:00:00")
temp <- vector(length=length(times))
monthDay = "11-04"
# My own code
# Can take in a vector aswell. Good.
gaussianKernel = function(x1,x2, h) {
u = (x1 - x2)/h
return(exp(-(u^2)))
}
convert_to_mins = function(time) {
return(as.numeric(substr(time,1,2))*60 + as.numeric(substr(time,4,5)))
}
gaussianDateKernel = function(day1, day2, h) {
if (length(day2 > 1)) {
daysBetween = apply(as.matrix(day2), 1, function(d2) {
min(366 - abs(day1 - d2), abs(day1 - d2))
})
} else {
daysBetween = min(366 - abs(day1 - day2), abs(day1 - day2))
}
return(exp(-(daysBetween^2)/(h^2)))
}
gaussianDistKernel = function(dist, h) {
return(exp(-(dist^2)/(h^2)))
}
# Time received in minutes
timeKernel = function(time1, time2, h) {
timeDiff = abs((time1 - time2)/60)
#print(timeDiff)
if (length(timeDiff) > 1) {
timeDiff = apply(as.matrix(timeDiff), 1, function(row) {
if (row > 12) {
return(12 - row %% 12)
} else {
return(row)
}
})
}
return(exp(-(timeDiff^2)/(h^2)))
}
sumKernel = function(dist1, dist2, date1, date2, time1, time2) {
return(gaussianDistKernel(dist1, dist2, h_distance) +
gaussianDateKernel(date1, date2, h_date) +
timeKernel(time1, time2, h_time))
}
prodKernel = function(dist1, dist2, date1, date2, time1, time2) {
return(gaussianDistKernel(dist1, dist2, h_distance) *
gaussianDateKernel(date1, date2, h_date) *
timeKernel(time1, time2, h_time))
}
# Preprocess data to use
featuresToUse = data.matrix(st[,-c(1,2,3,6,7)])
# Set time to minutes
featuresToUse[,5] = apply(as.matrix(as.character(st$time)),1,convert_to_mins)#convert_to_mins(st$time)
featuresToUse = featuresToUse[,-c(3,7)]
featuresToUse[,1] = as.numeric(featuresToUse[,1])
featuresToUse[,2] = as.numeric(featuresToUse[,2])
# For sensitivity; show distance between
# Norrkoping and linkoping and different hours and different days
get_points = function(stationName, date, times, monthDay) {
point = matrix(NA, nrow = length(times), ncol = 5)
point[,1] = rep(as.numeric(stations[stations$station_name == stationName,]$latitude),
times = length(times))
point[,2] = rep(as.numeric(stations[stations$station_name == stationName,]$longitude),
times = length(times))
point[,3] = rep(factor(date,
levels = levels(st$date)),
times = length(times))
point[,4] = apply(as.matrix(times), 1, convert_to_mins)
point[,5] = factor(monthDay,
levels = levels(temps$MonthDay))
colnames(point) = c(colnames(featuresToUse)[1:4],colnames(featuresToUse)[6])
return(point)
}
pred_point_sum_kernel = function(pointToPred, data) {
data = data[data[,3] <= pointToPred[3],]
temps_data = as.matrix(data[,5])
distances = apply(data[,1:2], 1, function(dataCoords) {
return(distHaversine(dataCoords, pointToPred[1:2]))
})
kernSum = as.matrix(timeKernel(time1 = rep(pointToPred[4], times = nrow(data)),
time2 = data[,4], h = h_time) +
gaussianDistKernel(dist = distances,
h = h_distance) +
gaussianDateKernel(day1 = rep(pointToPred[3],
times = nrow(data)),
day2 = data[,3],
h = h_date))
above = (t(kernSum)%*%temps_data)[1,1]
below = sum(kernSum)
return(above/below)
}
pred_point_prod_kernel = function(pointToPred, data) {
data = data[data[,3] <= pointToPred[3],]
temps_data = as.matrix(data[,5])
distances = apply(data[,1:2], 1, function(dataCoords) {
return(distHaversine(dataCoords, pointToPred[1:2]))
})
kernProd = as.matrix(timeKernel(time1 = rep(pointToPred[4], times = nrow(data)),
time2 = data[,4],
h = h_time) *
gaussianDistKernel(dist = distances,
h = h_distance) *
gaussianDateKernel(day1 = rep(pointToPred[3], times = nrow(data)),
day2 = data[,3],
h = h_date))
above = (t(kernProd)%*%temps_data)[1,1]
below = sum(kernProd)
return(above/below)
}
norrkopingTimes = get_points(stationName = "Norrköping",
date = date,
times = times,
monthDay = monthDay)
LinkopingTimes = get_points(stationName = "Linköping",
date = date,
times = times,
monthDay = monthDay)
# Calculate temp
tempsSum = as.numeric()
tempsProd = as.numeric()
for (i in 1:nrow(norrkopingTimes)) {
tempsSum[i] = pred_point_sum_kernel(norrkopingTimes[i,], data = featuresToUse)
tempsProd[i] = pred_point_prod_kernel(norrkopingTimes[i,], data = featuresToUse)
}
norrkopingTimes = get_points(stationName = "Norrköping",
date = date,
times = times,
monthDay = monthDay)
LinkopingTimes = get_points(stationName = "Linköping",
date = date,
times = times,
monthDay = monthDay)
# Calculate temp
tempsSum = as.numeric()
tempsProd = as.numeric()
count = 0
for (i in 1:nrow(norrkopingTimes)) {
tempsSum[i] = pred_point_sum_kernel(norrkopingTimes[i,], data = featuresToUse)
tempsProd[i] = pred_point_prod_kernel(norrkopingTimes[i,], data = featuresToUse)
count = count + 1
print(count)
}
# Plot
plot(tempsSum, type="o",
ylim = c(min(tempsSum,tempsProd), max(tempsSum,tempsProd)),
col = "red", lwd = 3, xlab = "Time", ylab = "Temperature")
lines(tempsProd, type = "o", col = "blue", lwd = 3)
axis(1, at=1:11, labels=times)
h_distance <- 100000 # reasonable that it is the same within 200km more or less
h_date <- 10 # If the year was extra cold. Reasonable to have within one year.
h_time <- 2 # About an hour ish. Reasonable.
set.seed(1234567890)
library(geosphere)
stations <- read.csv("stations.csv",
stringsAsFactors=FALSE,
fileEncoding="latin1")
temps <- read.csv("temps50k.csv")
# Creating Month and Day of year.
temps$MonthDay = factor(substr(as.character(temps$date),
start = 6,
stop = 10))
st <- merge(stations,temps,by="station_number")
date <- "2013-11-04" # The date to predict (up to the students)
times <- c("04:00:00", "06:00:00", "08:00:00", "10:00:00",
"12:00:00", "14:00:00", "16:00:00", "18:00:00",
"20:00:00", "22:00:00", "00:00:00")
temp <- vector(length=length(times))
monthDay = "11-04"
# My own code
# Can take in a vector aswell. Good.
# gaussianKernel = function(x1,x2, h) {
#   u = (x1 - x2)/h
#   return(exp(-(u^2)))
# }
convert_to_mins = function(time) {
return(as.numeric(substr(time,1,2))*60 + as.numeric(substr(time,4,5)))
}
gaussianDateKernel = function(day1, day2, h) {
if (length(day2 > 1)) {
daysBetween = apply(as.matrix(day2), 1, function(d2) {
min(366 - abs(day1 - d2), abs(day1 - d2))
})
} else {
daysBetween = min(366 - abs(day1 - day2), abs(day1 - day2))
}
return(exp(-(daysBetween^2)/(h^2)))
}
gaussianDistKernel = function(dist, h) {
return(exp(-(dist^2)/(h^2)))
}
# Time received in minutes
timeKernel = function(time1, time2, h) {
timeDiff = abs((time1 - time2)/60)
#print(timeDiff)
if (length(timeDiff) > 1) {
timeDiff = apply(as.matrix(timeDiff), 1, function(row) {
if (row > 12) {
return(12 - row %% 12)
} else {
return(row)
}
})
}
return(exp(-(timeDiff^2)/(h^2)))
}
sumKernel = function(dist1, dist2, date1, date2, time1, time2) {
return(gaussianDistKernel(dist1, dist2, h_distance) +
gaussianDateKernel(date1, date2, h_date) +
timeKernel(time1, time2, h_time))
}
prodKernel = function(dist1, dist2, date1, date2, time1, time2) {
return(gaussianDistKernel(dist1, dist2, h_distance) *
gaussianDateKernel(date1, date2, h_date) *
timeKernel(time1, time2, h_time))
}
# Preprocess data to use
featuresToUse = data.matrix(st[,-c(1,2,3,6,7)])
# Set time to minutes
featuresToUse[,5] = apply(as.matrix(as.character(st$time)),1,convert_to_mins)#convert_to_mins(st$time)
featuresToUse = featuresToUse[,-c(3,7)]
featuresToUse[,1] = as.numeric(featuresToUse[,1])
featuresToUse[,2] = as.numeric(featuresToUse[,2])
# For sensitivity; show distance between
# Norrkoping and linkoping and different hours and different days
get_points = function(stationName, date, times, monthDay) {
point = matrix(NA, nrow = length(times), ncol = 5)
point[,1] = rep(as.numeric(stations[stations$station_name == stationName,]$latitude),
times = length(times))
point[,2] = rep(as.numeric(stations[stations$station_name == stationName,]$longitude),
times = length(times))
point[,3] = rep(factor(date,
levels = levels(st$date)),
times = length(times))
point[,4] = apply(as.matrix(times), 1, convert_to_mins)
point[,5] = factor(monthDay,
levels = levels(temps$MonthDay))
colnames(point) = c(colnames(featuresToUse)[1:4],colnames(featuresToUse)[6])
return(point)
}
pred_point_sum_kernel = function(pointToPred, data) {
data = data[data[,3] <= pointToPred[3],]
temps_data = as.matrix(data[,5])
distances = apply(data[,1:2], 1, function(dataCoords) {
return(distHaversine(dataCoords, pointToPred[1:2]))
})
kernSum = as.matrix(timeKernel(time1 = rep(pointToPred[4], times = nrow(data)),
time2 = data[,4], h = h_time) +
gaussianDistKernel(dist = distances,
h = h_distance) +
gaussianDateKernel(day1 = rep(pointToPred[3],
times = nrow(data)),
day2 = data[,3],
h = h_date))
above = (t(kernSum)%*%temps_data)[1,1]
below = sum(kernSum)
return(above/below)
}
pred_point_prod_kernel = function(pointToPred, data) {
data = data[data[,3] <= pointToPred[3],]
temps_data = as.matrix(data[,5])
distances = apply(data[,1:2], 1, function(dataCoords) {
return(distHaversine(dataCoords, pointToPred[1:2]))
})
kernProd = as.matrix(timeKernel(time1 = rep(pointToPred[4], times = nrow(data)),
time2 = data[,4],
h = h_time) *
gaussianDistKernel(dist = distances,
h = h_distance) *
gaussianDateKernel(day1 = rep(pointToPred[3], times = nrow(data)),
day2 = data[,3],
h = h_date))
above = (t(kernProd)%*%temps_data)[1,1]
below = sum(kernProd)
return(above/below)
}
norrkopingTimes = get_points(stationName = "Norrköping",
date = date,
times = times,
monthDay = monthDay)
LinkopingTimes = get_points(stationName = "Linköping",
date = date,
times = times,
monthDay = monthDay)
# Calculate temp
tempsSum = as.numeric()
tempsProd = as.numeric()
count = 0
for (i in 1:nrow(norrkopingTimes)) {
tempsSum[i] = pred_point_sum_kernel(norrkopingTimes[i,], data = featuresToUse)
tempsProd[i] = pred_point_prod_kernel(norrkopingTimes[i,], data = featuresToUse)
count = count + 1
print(count)
}
# Plot
plot(tempsSum, type="o",
ylim = c(min(tempsSum,tempsProd), max(tempsSum,tempsProd)),
col = "red", lwd = 3, xlab = "Time", ylab = "Temperature")
lines(tempsProd, type = "o", col = "blue", lwd = 3)
axis(1, at=1:11, labels=times)
par(mfrow=c(2,2))
distSeq = seq(-400000, 400000, 40)
plot(x=distSeq,
gaussianDistKernel(dist = distSeq, h = h_distance),
type = "l", lwd = 3,
xlab = "Distance",
ylab = "Gaussian distance kernel value",
main = "Sensibility distance kernel")
# Show for time
timeSeq = seq(1,170,1)
plot(x=timeSeq, y = gaussianKernel(x1 = 40, x2 = timeSeq, h = h_time),
type = "l",
lwd = 3,
xlab = "Time",
ylab = "Gaussian kernel value",
main = "Sensibility time kernel for t = 05:25:00")
dateSeq = seq(1,19049,1)
plot(x=dateSeq,
y = gaussianKernel(x1 = 4000, x2 = dateSeq, h = h_date),
type = "l", lwd = 3,
xlab = "Date",
ylab = "Gaussian kernel value",
main = "Sensibility date kernel for date = 1970-02-05")
dateSeq = seq(1,366,1)
plot(x=dateSeq,
y = seasonalKernel(day1 = 10, day2 = dateSeq, h = h_season),
type = "l", lwd = 3, xlab = "Date of year",
ylab = "Gaussian kernel value",
main = "Sensibility seasonal kernel for date = day 10")
par(mfrow=c(2,2))
distSeq = seq(-400000, 400000, 40)
plot(x=distSeq,
gaussianDistKernel(dist = distSeq, h = h_distance),
type = "l", lwd = 3,
xlab = "Distance",
ylab = "Gaussian distance kernel value",
main = "Sensibility distance kernel")
# Show for time
timeSeq = seq(1,170,1)
plot(x=timeSeq, y = gaussianKernel(x1 = 40, x2 = timeSeq, h = h_time),
type = "l",
lwd = 3,
xlab = "Time",
ylab = "Gaussian kernel value",
main = "Sensibility time kernel for t = 05:25:00")
dateSeq = seq(1,366,1)
plot(x=dateSeq,
y = gaussianDateKernel(day1 = 10, day2 = dateSeq, h = h_season),
type = "l", lwd = 3, xlab = "Date of year",
ylab = "Gaussian kernel value",
main = "Sensibility seasonal kernel for date = day 10")
60*24
par(mfrow=c(2,2))
distSeq = seq(-400000, 400000, 40)
plot(x=distSeq,
gaussianDistKernel(dist = distSeq, h = h_distance),
type = "l", lwd = 3,
xlab = "Distance",
ylab = "Gaussian distance kernel value",
main = "Sensibility distance kernel")
# Show for time
timeSeq = seq(1,1440,1)
plot(x=timeSeq, y = timeKernel(time1 = 60*7, time2 = timeSeq, h = h_time),
type = "l",
lwd = 3,
xlab = "Time",
ylab = "Gaussian kernel value",
main = "Sensibility time kernel for t = 07:00:00")
dateSeq = seq(1,366,1)
plot(x=dateSeq,
y = gaussianDateKernel(day1 = 10, day2 = dateSeq, h = h_season),
type = "l", lwd = 3, xlab = "Date of year",
ylab = "Gaussian kernel value",
main = "Sensibility seasonal kernel for date = day 10")
par(mfrow=c(2,2))
distSeq = seq(-400000, 400000, 40)
plot(x=distSeq,
gaussianDistKernel(dist = distSeq, h = h_distance),
type = "l", lwd = 3,
xlab = "Distance",
ylab = "Gaussian distance kernel value",
main = "Sensibility distance kernel")
# Show for time
timeSeq = seq(1,1440,1)
plot(x=timeSeq, y = timeKernel(time1 = 60*7, time2 = timeSeq, h = h_time),
type = "l",
lwd = 3,
xlab = "Time",
ylab = "Gaussian kernel value",
main = "Sensibility time kernel for t = 07:00:00")
dateSeq = seq(1,366,1)
plot(x=dateSeq,
y = gaussianDateKernel(day1 = 10, day2 = dateSeq, h = h_date),
type = "l", lwd = 3, xlab = "Date of year",
ylab = "Gaussian kernel value",
main = "Sensibility seasonal kernel for date = day 10")
par(mfrow=c(1,1))
#https://hilaryparker.com/2014/04/29/writing-an-r-package-from-scratch/
# create("Filips.ML.package")
# setwd("./cats")
# document()
#' When update to package is done (for Filips ML package):
#' 1. Set working directory to package.
#' 2. setwd("~/Desktop/Programmeringsprojekt/Machine Learning/Filips ML package/Filips.ML.package")
#'    document()
#' 3. Set working directory to folder above and reinstall the package with updates.
#'    setwd("~/Desktop/Programmeringsprojekt/Machine Learning/Filips ML package")
#'    install("Filips.ML.package")
#'
# To use the ML functions, run the code below.
library("devtools")
library(roxygen2)
setwd("/Users/filipcornell/Desktop/Programmeringsprojekt/ML-Implementations/Filips ML package/Filips.ML.package")
document()
setwd("/Users/filipcornell/Desktop/Programmeringsprojekt/ML-Implementations/Filips ML package")
install("Filips.ML.package")
#this.dir <- dirname(parent.frame(2)$ofile) #To set it to source file location
#setwd(this.dir) #To set it to source file location
#library("Filips.ML.package")
#https://hilaryparker.com/2014/04/29/writing-an-r-package-from-scratch/
# create("Filips.ML.package")
# setwd("./cats")
# document()
#' When update to package is done (for Filips ML package):
#' 1. Set working directory to package.
#' 2. setwd("~/Desktop/Programmeringsprojekt/Machine Learning/Filips ML package/Filips.ML.package")
#'    document()
#' 3. Set working directory to folder above and reinstall the package with updates.
#'    setwd("~/Desktop/Programmeringsprojekt/Machine Learning/Filips ML package")
#'    install("Filips.ML.package")
#'
# To use the ML functions, run the code below.
library("devtools")
library(roxygen2)
setwd("/Users/filipcornell/Desktop/Programmeringsprojekt/ML-Implementations/Filips ML package/Filips.ML.package")
document()
setwd("/Users/filipcornell/Desktop/Programmeringsprojekt/ML-Implementations/Filips ML package")
install("Filips.ML.package")
#this.dir <- dirname(parent.frame(2)$ofile) #To set it to source file location
#setwd(this.dir) #To set it to source file location
#library("Filips.ML.package")
